// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: model.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_model_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_model_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "gogoproto/gogo.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_model_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_model_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_model_2eproto;
namespace jaeger {
namespace api_v2 {
class Batch;
class BatchDefaultTypeInternal;
extern BatchDefaultTypeInternal _Batch_default_instance_;
class DependencyLink;
class DependencyLinkDefaultTypeInternal;
extern DependencyLinkDefaultTypeInternal _DependencyLink_default_instance_;
class KeyValue;
class KeyValueDefaultTypeInternal;
extern KeyValueDefaultTypeInternal _KeyValue_default_instance_;
class Log;
class LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class Process;
class ProcessDefaultTypeInternal;
extern ProcessDefaultTypeInternal _Process_default_instance_;
class Span;
class SpanDefaultTypeInternal;
extern SpanDefaultTypeInternal _Span_default_instance_;
class SpanRef;
class SpanRefDefaultTypeInternal;
extern SpanRefDefaultTypeInternal _SpanRef_default_instance_;
class Trace;
class TraceDefaultTypeInternal;
extern TraceDefaultTypeInternal _Trace_default_instance_;
class Trace_ProcessMapping;
class Trace_ProcessMappingDefaultTypeInternal;
extern Trace_ProcessMappingDefaultTypeInternal _Trace_ProcessMapping_default_instance_;
}  // namespace api_v2
}  // namespace jaeger
PROTOBUF_NAMESPACE_OPEN
template<> ::jaeger::api_v2::Batch* Arena::CreateMaybeMessage<::jaeger::api_v2::Batch>(Arena*);
template<> ::jaeger::api_v2::DependencyLink* Arena::CreateMaybeMessage<::jaeger::api_v2::DependencyLink>(Arena*);
template<> ::jaeger::api_v2::KeyValue* Arena::CreateMaybeMessage<::jaeger::api_v2::KeyValue>(Arena*);
template<> ::jaeger::api_v2::Log* Arena::CreateMaybeMessage<::jaeger::api_v2::Log>(Arena*);
template<> ::jaeger::api_v2::Process* Arena::CreateMaybeMessage<::jaeger::api_v2::Process>(Arena*);
template<> ::jaeger::api_v2::Span* Arena::CreateMaybeMessage<::jaeger::api_v2::Span>(Arena*);
template<> ::jaeger::api_v2::SpanRef* Arena::CreateMaybeMessage<::jaeger::api_v2::SpanRef>(Arena*);
template<> ::jaeger::api_v2::Trace* Arena::CreateMaybeMessage<::jaeger::api_v2::Trace>(Arena*);
template<> ::jaeger::api_v2::Trace_ProcessMapping* Arena::CreateMaybeMessage<::jaeger::api_v2::Trace_ProcessMapping>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace jaeger {
namespace api_v2 {

enum ValueType : int {
  STRING = 0,
  BOOL = 1,
  INT64 = 2,
  FLOAT64 = 3,
  BINARY = 4,
  ValueType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ValueType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ValueType_IsValid(int value);
constexpr ValueType ValueType_MIN = STRING;
constexpr ValueType ValueType_MAX = BINARY;
constexpr int ValueType_ARRAYSIZE = ValueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ValueType_descriptor();
template<typename T>
inline const std::string& ValueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ValueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ValueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ValueType_descriptor(), enum_t_value);
}
inline bool ValueType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ValueType>(
    ValueType_descriptor(), name, value);
}
enum SpanRefType : int {
  CHILD_OF = 0,
  FOLLOWS_FROM = 1,
  SpanRefType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SpanRefType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SpanRefType_IsValid(int value);
constexpr SpanRefType SpanRefType_MIN = CHILD_OF;
constexpr SpanRefType SpanRefType_MAX = FOLLOWS_FROM;
constexpr int SpanRefType_ARRAYSIZE = SpanRefType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpanRefType_descriptor();
template<typename T>
inline const std::string& SpanRefType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpanRefType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpanRefType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpanRefType_descriptor(), enum_t_value);
}
inline bool SpanRefType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpanRefType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpanRefType>(
    SpanRefType_descriptor(), name, value);
}
// ===================================================================

class KeyValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jaeger.api_v2.KeyValue) */ {
 public:
  inline KeyValue() : KeyValue(nullptr) {}
  virtual ~KeyValue();

  KeyValue(const KeyValue& from);
  KeyValue(KeyValue&& from) noexcept
    : KeyValue() {
    *this = ::std::move(from);
  }

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValue& operator=(KeyValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeyValue& default_instance();

  static inline const KeyValue* internal_default_instance() {
    return reinterpret_cast<const KeyValue*>(
               &_KeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(KeyValue& a, KeyValue& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyValue* New() const final {
    return CreateMaybeMessage<KeyValue>(nullptr);
  }

  KeyValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jaeger.api_v2.KeyValue";
  }
  protected:
  explicit KeyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_2eproto);
    return ::descriptor_table_model_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kVStrFieldNumber = 3,
    kVBinaryFieldNumber = 7,
    kVTypeFieldNumber = 2,
    kVBoolFieldNumber = 4,
    kVInt64FieldNumber = 5,
    kVFloat64FieldNumber = 6,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string v_str = 3;
  void clear_v_str();
  const std::string& v_str() const;
  void set_v_str(const std::string& value);
  void set_v_str(std::string&& value);
  void set_v_str(const char* value);
  void set_v_str(const char* value, size_t size);
  std::string* mutable_v_str();
  std::string* release_v_str();
  void set_allocated_v_str(std::string* v_str);
  private:
  const std::string& _internal_v_str() const;
  void _internal_set_v_str(const std::string& value);
  std::string* _internal_mutable_v_str();
  public:

  // bytes v_binary = 7;
  void clear_v_binary();
  const std::string& v_binary() const;
  void set_v_binary(const std::string& value);
  void set_v_binary(std::string&& value);
  void set_v_binary(const char* value);
  void set_v_binary(const void* value, size_t size);
  std::string* mutable_v_binary();
  std::string* release_v_binary();
  void set_allocated_v_binary(std::string* v_binary);
  private:
  const std::string& _internal_v_binary() const;
  void _internal_set_v_binary(const std::string& value);
  std::string* _internal_mutable_v_binary();
  public:

  // .jaeger.api_v2.ValueType v_type = 2;
  void clear_v_type();
  ::jaeger::api_v2::ValueType v_type() const;
  void set_v_type(::jaeger::api_v2::ValueType value);
  private:
  ::jaeger::api_v2::ValueType _internal_v_type() const;
  void _internal_set_v_type(::jaeger::api_v2::ValueType value);
  public:

  // bool v_bool = 4;
  void clear_v_bool();
  bool v_bool() const;
  void set_v_bool(bool value);
  private:
  bool _internal_v_bool() const;
  void _internal_set_v_bool(bool value);
  public:

  // int64 v_int64 = 5;
  void clear_v_int64();
  ::PROTOBUF_NAMESPACE_ID::int64 v_int64() const;
  void set_v_int64(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_v_int64() const;
  void _internal_set_v_int64(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double v_float64 = 6;
  void clear_v_float64();
  double v_float64() const;
  void set_v_float64(double value);
  private:
  double _internal_v_float64() const;
  void _internal_set_v_float64(double value);
  public:

  // @@protoc_insertion_point(class_scope:jaeger.api_v2.KeyValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_str_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_binary_;
  int v_type_;
  bool v_bool_;
  ::PROTOBUF_NAMESPACE_ID::int64 v_int64_;
  double v_float64_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Log PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jaeger.api_v2.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  virtual ~Log();

  Log(const Log& from);
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Log& default_instance();

  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Log* New() const final {
    return CreateMaybeMessage<Log>(nullptr);
  }

  Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Log& from);
  void MergeFrom(const Log& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jaeger.api_v2.Log";
  }
  protected:
  explicit Log(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_2eproto);
    return ::descriptor_table_model_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 2,
    kTimestampFieldNumber = 1,
  };
  // repeated .jaeger.api_v2.KeyValue fields = 2 [(.gogoproto.nullable) = false];
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::jaeger::api_v2::KeyValue* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue >*
      mutable_fields();
  private:
  const ::jaeger::api_v2::KeyValue& _internal_fields(int index) const;
  ::jaeger::api_v2::KeyValue* _internal_add_fields();
  public:
  const ::jaeger::api_v2::KeyValue& fields(int index) const;
  ::jaeger::api_v2::KeyValue* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue >&
      fields() const;

  // .google.protobuf.Timestamp timestamp = 1 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:jaeger.api_v2.Log)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue > fields_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class SpanRef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jaeger.api_v2.SpanRef) */ {
 public:
  inline SpanRef() : SpanRef(nullptr) {}
  virtual ~SpanRef();

  SpanRef(const SpanRef& from);
  SpanRef(SpanRef&& from) noexcept
    : SpanRef() {
    *this = ::std::move(from);
  }

  inline SpanRef& operator=(const SpanRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpanRef& operator=(SpanRef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpanRef& default_instance();

  static inline const SpanRef* internal_default_instance() {
    return reinterpret_cast<const SpanRef*>(
               &_SpanRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SpanRef& a, SpanRef& b) {
    a.Swap(&b);
  }
  inline void Swap(SpanRef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpanRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpanRef* New() const final {
    return CreateMaybeMessage<SpanRef>(nullptr);
  }

  SpanRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpanRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpanRef& from);
  void MergeFrom(const SpanRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpanRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jaeger.api_v2.SpanRef";
  }
  protected:
  explicit SpanRef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_2eproto);
    return ::descriptor_table_model_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTraceIdFieldNumber = 1,
    kSpanIdFieldNumber = 2,
    kRefTypeFieldNumber = 3,
  };
  // bytes trace_id = 1 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "TraceID", (.gogoproto.customname) = "TraceID"];
  void clear_trace_id();
  const std::string& trace_id() const;
  void set_trace_id(const std::string& value);
  void set_trace_id(std::string&& value);
  void set_trace_id(const char* value);
  void set_trace_id(const void* value, size_t size);
  std::string* mutable_trace_id();
  std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // bytes span_id = 2 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "SpanID", (.gogoproto.customname) = "SpanID"];
  void clear_span_id();
  const std::string& span_id() const;
  void set_span_id(const std::string& value);
  void set_span_id(std::string&& value);
  void set_span_id(const char* value);
  void set_span_id(const void* value, size_t size);
  std::string* mutable_span_id();
  std::string* release_span_id();
  void set_allocated_span_id(std::string* span_id);
  private:
  const std::string& _internal_span_id() const;
  void _internal_set_span_id(const std::string& value);
  std::string* _internal_mutable_span_id();
  public:

  // .jaeger.api_v2.SpanRefType ref_type = 3;
  void clear_ref_type();
  ::jaeger::api_v2::SpanRefType ref_type() const;
  void set_ref_type(::jaeger::api_v2::SpanRefType value);
  private:
  ::jaeger::api_v2::SpanRefType _internal_ref_type() const;
  void _internal_set_ref_type(::jaeger::api_v2::SpanRefType value);
  public:

  // @@protoc_insertion_point(class_scope:jaeger.api_v2.SpanRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr span_id_;
  int ref_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Process PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jaeger.api_v2.Process) */ {
 public:
  inline Process() : Process(nullptr) {}
  virtual ~Process();

  Process(const Process& from);
  Process(Process&& from) noexcept
    : Process() {
    *this = ::std::move(from);
  }

  inline Process& operator=(const Process& from) {
    CopyFrom(from);
    return *this;
  }
  inline Process& operator=(Process&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Process& default_instance();

  static inline const Process* internal_default_instance() {
    return reinterpret_cast<const Process*>(
               &_Process_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Process& a, Process& b) {
    a.Swap(&b);
  }
  inline void Swap(Process* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Process* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Process* New() const final {
    return CreateMaybeMessage<Process>(nullptr);
  }

  Process* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Process>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Process& from);
  void MergeFrom(const Process& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Process* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jaeger.api_v2.Process";
  }
  protected:
  explicit Process(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_2eproto);
    return ::descriptor_table_model_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 2,
    kServiceNameFieldNumber = 1,
  };
  // repeated .jaeger.api_v2.KeyValue tags = 2 [(.gogoproto.nullable) = false];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::jaeger::api_v2::KeyValue* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue >*
      mutable_tags();
  private:
  const ::jaeger::api_v2::KeyValue& _internal_tags(int index) const;
  ::jaeger::api_v2::KeyValue* _internal_add_tags();
  public:
  const ::jaeger::api_v2::KeyValue& tags(int index) const;
  ::jaeger::api_v2::KeyValue* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue >&
      tags() const;

  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // @@protoc_insertion_point(class_scope:jaeger.api_v2.Process)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue > tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Span PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jaeger.api_v2.Span) */ {
 public:
  inline Span() : Span(nullptr) {}
  virtual ~Span();

  Span(const Span& from);
  Span(Span&& from) noexcept
    : Span() {
    *this = ::std::move(from);
  }

  inline Span& operator=(const Span& from) {
    CopyFrom(from);
    return *this;
  }
  inline Span& operator=(Span&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Span& default_instance();

  static inline const Span* internal_default_instance() {
    return reinterpret_cast<const Span*>(
               &_Span_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Span& a, Span& b) {
    a.Swap(&b);
  }
  inline void Swap(Span* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Span* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Span* New() const final {
    return CreateMaybeMessage<Span>(nullptr);
  }

  Span* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Span>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Span& from);
  void MergeFrom(const Span& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Span* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jaeger.api_v2.Span";
  }
  protected:
  explicit Span(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_2eproto);
    return ::descriptor_table_model_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReferencesFieldNumber = 4,
    kTagsFieldNumber = 8,
    kLogsFieldNumber = 9,
    kWarningsFieldNumber = 12,
    kTraceIdFieldNumber = 1,
    kSpanIdFieldNumber = 2,
    kOperationNameFieldNumber = 3,
    kProcessIdFieldNumber = 11,
    kStartTimeFieldNumber = 6,
    kDurationFieldNumber = 7,
    kProcessFieldNumber = 10,
    kFlagsFieldNumber = 5,
  };
  // repeated .jaeger.api_v2.SpanRef references = 4 [(.gogoproto.nullable) = false];
  int references_size() const;
  private:
  int _internal_references_size() const;
  public:
  void clear_references();
  ::jaeger::api_v2::SpanRef* mutable_references(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::SpanRef >*
      mutable_references();
  private:
  const ::jaeger::api_v2::SpanRef& _internal_references(int index) const;
  ::jaeger::api_v2::SpanRef* _internal_add_references();
  public:
  const ::jaeger::api_v2::SpanRef& references(int index) const;
  ::jaeger::api_v2::SpanRef* add_references();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::SpanRef >&
      references() const;

  // repeated .jaeger.api_v2.KeyValue tags = 8 [(.gogoproto.nullable) = false];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::jaeger::api_v2::KeyValue* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue >*
      mutable_tags();
  private:
  const ::jaeger::api_v2::KeyValue& _internal_tags(int index) const;
  ::jaeger::api_v2::KeyValue* _internal_add_tags();
  public:
  const ::jaeger::api_v2::KeyValue& tags(int index) const;
  ::jaeger::api_v2::KeyValue* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue >&
      tags() const;

  // repeated .jaeger.api_v2.Log logs = 9 [(.gogoproto.nullable) = false];
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::jaeger::api_v2::Log* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Log >*
      mutable_logs();
  private:
  const ::jaeger::api_v2::Log& _internal_logs(int index) const;
  ::jaeger::api_v2::Log* _internal_add_logs();
  public:
  const ::jaeger::api_v2::Log& logs(int index) const;
  ::jaeger::api_v2::Log* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Log >&
      logs() const;

  // repeated string warnings = 12;
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;
  public:
  void clear_warnings();
  const std::string& warnings(int index) const;
  std::string* mutable_warnings(int index);
  void set_warnings(int index, const std::string& value);
  void set_warnings(int index, std::string&& value);
  void set_warnings(int index, const char* value);
  void set_warnings(int index, const char* value, size_t size);
  std::string* add_warnings();
  void add_warnings(const std::string& value);
  void add_warnings(std::string&& value);
  void add_warnings(const char* value);
  void add_warnings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& warnings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_warnings();
  private:
  const std::string& _internal_warnings(int index) const;
  std::string* _internal_add_warnings();
  public:

  // bytes trace_id = 1 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "TraceID", (.gogoproto.customname) = "TraceID"];
  void clear_trace_id();
  const std::string& trace_id() const;
  void set_trace_id(const std::string& value);
  void set_trace_id(std::string&& value);
  void set_trace_id(const char* value);
  void set_trace_id(const void* value, size_t size);
  std::string* mutable_trace_id();
  std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // bytes span_id = 2 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "SpanID", (.gogoproto.customname) = "SpanID"];
  void clear_span_id();
  const std::string& span_id() const;
  void set_span_id(const std::string& value);
  void set_span_id(std::string&& value);
  void set_span_id(const char* value);
  void set_span_id(const void* value, size_t size);
  std::string* mutable_span_id();
  std::string* release_span_id();
  void set_allocated_span_id(std::string* span_id);
  private:
  const std::string& _internal_span_id() const;
  void _internal_set_span_id(const std::string& value);
  std::string* _internal_mutable_span_id();
  public:

  // string operation_name = 3;
  void clear_operation_name();
  const std::string& operation_name() const;
  void set_operation_name(const std::string& value);
  void set_operation_name(std::string&& value);
  void set_operation_name(const char* value);
  void set_operation_name(const char* value, size_t size);
  std::string* mutable_operation_name();
  std::string* release_operation_name();
  void set_allocated_operation_name(std::string* operation_name);
  private:
  const std::string& _internal_operation_name() const;
  void _internal_set_operation_name(const std::string& value);
  std::string* _internal_mutable_operation_name();
  public:

  // string process_id = 11 [(.gogoproto.customname) = "ProcessID"];
  void clear_process_id();
  const std::string& process_id() const;
  void set_process_id(const std::string& value);
  void set_process_id(std::string&& value);
  void set_process_id(const char* value);
  void set_process_id(const char* value, size_t size);
  std::string* mutable_process_id();
  std::string* release_process_id();
  void set_allocated_process_id(std::string* process_id);
  private:
  const std::string& _internal_process_id() const;
  void _internal_set_process_id(const std::string& value);
  std::string* _internal_mutable_process_id();
  public:

  // .google.protobuf.Timestamp start_time = 6 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Duration duration = 7 [(.gogoproto.nullable) = false, (.gogoproto.stdduration) = true];
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const PROTOBUF_NAMESPACE_ID::Duration& duration() const;
  PROTOBUF_NAMESPACE_ID::Duration* release_duration();
  PROTOBUF_NAMESPACE_ID::Duration* mutable_duration();
  void set_allocated_duration(PROTOBUF_NAMESPACE_ID::Duration* duration);
  private:
  const PROTOBUF_NAMESPACE_ID::Duration& _internal_duration() const;
  PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      PROTOBUF_NAMESPACE_ID::Duration* duration);
  PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_duration();

  // .jaeger.api_v2.Process process = 10;
  bool has_process() const;
  private:
  bool _internal_has_process() const;
  public:
  void clear_process();
  const ::jaeger::api_v2::Process& process() const;
  ::jaeger::api_v2::Process* release_process();
  ::jaeger::api_v2::Process* mutable_process();
  void set_allocated_process(::jaeger::api_v2::Process* process);
  private:
  const ::jaeger::api_v2::Process& _internal_process() const;
  ::jaeger::api_v2::Process* _internal_mutable_process();
  public:
  void unsafe_arena_set_allocated_process(
      ::jaeger::api_v2::Process* process);
  ::jaeger::api_v2::Process* unsafe_arena_release_process();

  // uint32 flags = 5 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "Flags"];
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_flags() const;
  void _internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:jaeger.api_v2.Span)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::SpanRef > references_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue > tags_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Log > logs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> warnings_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr span_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr process_id_;
  PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
  PROTOBUF_NAMESPACE_ID::Duration* duration_;
  ::jaeger::api_v2::Process* process_;
  ::PROTOBUF_NAMESPACE_ID::uint32 flags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Trace_ProcessMapping PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jaeger.api_v2.Trace.ProcessMapping) */ {
 public:
  inline Trace_ProcessMapping() : Trace_ProcessMapping(nullptr) {}
  virtual ~Trace_ProcessMapping();

  Trace_ProcessMapping(const Trace_ProcessMapping& from);
  Trace_ProcessMapping(Trace_ProcessMapping&& from) noexcept
    : Trace_ProcessMapping() {
    *this = ::std::move(from);
  }

  inline Trace_ProcessMapping& operator=(const Trace_ProcessMapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trace_ProcessMapping& operator=(Trace_ProcessMapping&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Trace_ProcessMapping& default_instance();

  static inline const Trace_ProcessMapping* internal_default_instance() {
    return reinterpret_cast<const Trace_ProcessMapping*>(
               &_Trace_ProcessMapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Trace_ProcessMapping& a, Trace_ProcessMapping& b) {
    a.Swap(&b);
  }
  inline void Swap(Trace_ProcessMapping* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trace_ProcessMapping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Trace_ProcessMapping* New() const final {
    return CreateMaybeMessage<Trace_ProcessMapping>(nullptr);
  }

  Trace_ProcessMapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Trace_ProcessMapping>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Trace_ProcessMapping& from);
  void MergeFrom(const Trace_ProcessMapping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trace_ProcessMapping* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jaeger.api_v2.Trace.ProcessMapping";
  }
  protected:
  explicit Trace_ProcessMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_2eproto);
    return ::descriptor_table_model_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessIdFieldNumber = 1,
    kProcessFieldNumber = 2,
  };
  // string process_id = 1 [(.gogoproto.customname) = "ProcessID"];
  void clear_process_id();
  const std::string& process_id() const;
  void set_process_id(const std::string& value);
  void set_process_id(std::string&& value);
  void set_process_id(const char* value);
  void set_process_id(const char* value, size_t size);
  std::string* mutable_process_id();
  std::string* release_process_id();
  void set_allocated_process_id(std::string* process_id);
  private:
  const std::string& _internal_process_id() const;
  void _internal_set_process_id(const std::string& value);
  std::string* _internal_mutable_process_id();
  public:

  // .jaeger.api_v2.Process process = 2 [(.gogoproto.nullable) = false];
  bool has_process() const;
  private:
  bool _internal_has_process() const;
  public:
  void clear_process();
  const ::jaeger::api_v2::Process& process() const;
  ::jaeger::api_v2::Process* release_process();
  ::jaeger::api_v2::Process* mutable_process();
  void set_allocated_process(::jaeger::api_v2::Process* process);
  private:
  const ::jaeger::api_v2::Process& _internal_process() const;
  ::jaeger::api_v2::Process* _internal_mutable_process();
  public:
  void unsafe_arena_set_allocated_process(
      ::jaeger::api_v2::Process* process);
  ::jaeger::api_v2::Process* unsafe_arena_release_process();

  // @@protoc_insertion_point(class_scope:jaeger.api_v2.Trace.ProcessMapping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr process_id_;
  ::jaeger::api_v2::Process* process_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Trace PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jaeger.api_v2.Trace) */ {
 public:
  inline Trace() : Trace(nullptr) {}
  virtual ~Trace();

  Trace(const Trace& from);
  Trace(Trace&& from) noexcept
    : Trace() {
    *this = ::std::move(from);
  }

  inline Trace& operator=(const Trace& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trace& operator=(Trace&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Trace& default_instance();

  static inline const Trace* internal_default_instance() {
    return reinterpret_cast<const Trace*>(
               &_Trace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Trace& a, Trace& b) {
    a.Swap(&b);
  }
  inline void Swap(Trace* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Trace* New() const final {
    return CreateMaybeMessage<Trace>(nullptr);
  }

  Trace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Trace>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Trace& from);
  void MergeFrom(const Trace& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trace* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jaeger.api_v2.Trace";
  }
  protected:
  explicit Trace(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_2eproto);
    return ::descriptor_table_model_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Trace_ProcessMapping ProcessMapping;

  // accessors -------------------------------------------------------

  enum : int {
    kSpansFieldNumber = 1,
    kProcessMapFieldNumber = 2,
    kWarningsFieldNumber = 3,
  };
  // repeated .jaeger.api_v2.Span spans = 1;
  int spans_size() const;
  private:
  int _internal_spans_size() const;
  public:
  void clear_spans();
  ::jaeger::api_v2::Span* mutable_spans(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Span >*
      mutable_spans();
  private:
  const ::jaeger::api_v2::Span& _internal_spans(int index) const;
  ::jaeger::api_v2::Span* _internal_add_spans();
  public:
  const ::jaeger::api_v2::Span& spans(int index) const;
  ::jaeger::api_v2::Span* add_spans();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Span >&
      spans() const;

  // repeated .jaeger.api_v2.Trace.ProcessMapping process_map = 2 [(.gogoproto.nullable) = false];
  int process_map_size() const;
  private:
  int _internal_process_map_size() const;
  public:
  void clear_process_map();
  ::jaeger::api_v2::Trace_ProcessMapping* mutable_process_map(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Trace_ProcessMapping >*
      mutable_process_map();
  private:
  const ::jaeger::api_v2::Trace_ProcessMapping& _internal_process_map(int index) const;
  ::jaeger::api_v2::Trace_ProcessMapping* _internal_add_process_map();
  public:
  const ::jaeger::api_v2::Trace_ProcessMapping& process_map(int index) const;
  ::jaeger::api_v2::Trace_ProcessMapping* add_process_map();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Trace_ProcessMapping >&
      process_map() const;

  // repeated string warnings = 3;
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;
  public:
  void clear_warnings();
  const std::string& warnings(int index) const;
  std::string* mutable_warnings(int index);
  void set_warnings(int index, const std::string& value);
  void set_warnings(int index, std::string&& value);
  void set_warnings(int index, const char* value);
  void set_warnings(int index, const char* value, size_t size);
  std::string* add_warnings();
  void add_warnings(const std::string& value);
  void add_warnings(std::string&& value);
  void add_warnings(const char* value);
  void add_warnings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& warnings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_warnings();
  private:
  const std::string& _internal_warnings(int index) const;
  std::string* _internal_add_warnings();
  public:

  // @@protoc_insertion_point(class_scope:jaeger.api_v2.Trace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Span > spans_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Trace_ProcessMapping > process_map_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> warnings_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Batch PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jaeger.api_v2.Batch) */ {
 public:
  inline Batch() : Batch(nullptr) {}
  virtual ~Batch();

  Batch(const Batch& from);
  Batch(Batch&& from) noexcept
    : Batch() {
    *this = ::std::move(from);
  }

  inline Batch& operator=(const Batch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Batch& operator=(Batch&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Batch& default_instance();

  static inline const Batch* internal_default_instance() {
    return reinterpret_cast<const Batch*>(
               &_Batch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Batch& a, Batch& b) {
    a.Swap(&b);
  }
  inline void Swap(Batch* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Batch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Batch* New() const final {
    return CreateMaybeMessage<Batch>(nullptr);
  }

  Batch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Batch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Batch& from);
  void MergeFrom(const Batch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Batch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jaeger.api_v2.Batch";
  }
  protected:
  explicit Batch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_2eproto);
    return ::descriptor_table_model_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpansFieldNumber = 1,
    kProcessFieldNumber = 2,
  };
  // repeated .jaeger.api_v2.Span spans = 1;
  int spans_size() const;
  private:
  int _internal_spans_size() const;
  public:
  void clear_spans();
  ::jaeger::api_v2::Span* mutable_spans(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Span >*
      mutable_spans();
  private:
  const ::jaeger::api_v2::Span& _internal_spans(int index) const;
  ::jaeger::api_v2::Span* _internal_add_spans();
  public:
  const ::jaeger::api_v2::Span& spans(int index) const;
  ::jaeger::api_v2::Span* add_spans();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Span >&
      spans() const;

  // .jaeger.api_v2.Process process = 2 [(.gogoproto.nullable) = true];
  bool has_process() const;
  private:
  bool _internal_has_process() const;
  public:
  void clear_process();
  const ::jaeger::api_v2::Process& process() const;
  ::jaeger::api_v2::Process* release_process();
  ::jaeger::api_v2::Process* mutable_process();
  void set_allocated_process(::jaeger::api_v2::Process* process);
  private:
  const ::jaeger::api_v2::Process& _internal_process() const;
  ::jaeger::api_v2::Process* _internal_mutable_process();
  public:
  void unsafe_arena_set_allocated_process(
      ::jaeger::api_v2::Process* process);
  ::jaeger::api_v2::Process* unsafe_arena_release_process();

  // @@protoc_insertion_point(class_scope:jaeger.api_v2.Batch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Span > spans_;
  ::jaeger::api_v2::Process* process_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class DependencyLink PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jaeger.api_v2.DependencyLink) */ {
 public:
  inline DependencyLink() : DependencyLink(nullptr) {}
  virtual ~DependencyLink();

  DependencyLink(const DependencyLink& from);
  DependencyLink(DependencyLink&& from) noexcept
    : DependencyLink() {
    *this = ::std::move(from);
  }

  inline DependencyLink& operator=(const DependencyLink& from) {
    CopyFrom(from);
    return *this;
  }
  inline DependencyLink& operator=(DependencyLink&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DependencyLink& default_instance();

  static inline const DependencyLink* internal_default_instance() {
    return reinterpret_cast<const DependencyLink*>(
               &_DependencyLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DependencyLink& a, DependencyLink& b) {
    a.Swap(&b);
  }
  inline void Swap(DependencyLink* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DependencyLink* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DependencyLink* New() const final {
    return CreateMaybeMessage<DependencyLink>(nullptr);
  }

  DependencyLink* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DependencyLink>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DependencyLink& from);
  void MergeFrom(const DependencyLink& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DependencyLink* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jaeger.api_v2.DependencyLink";
  }
  protected:
  explicit DependencyLink(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_2eproto);
    return ::descriptor_table_model_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kChildFieldNumber = 2,
    kSourceFieldNumber = 4,
    kCallCountFieldNumber = 3,
  };
  // string parent = 1;
  void clear_parent();
  const std::string& parent() const;
  void set_parent(const std::string& value);
  void set_parent(std::string&& value);
  void set_parent(const char* value);
  void set_parent(const char* value, size_t size);
  std::string* mutable_parent();
  std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string child = 2;
  void clear_child();
  const std::string& child() const;
  void set_child(const std::string& value);
  void set_child(std::string&& value);
  void set_child(const char* value);
  void set_child(const char* value, size_t size);
  std::string* mutable_child();
  std::string* release_child();
  void set_allocated_child(std::string* child);
  private:
  const std::string& _internal_child() const;
  void _internal_set_child(const std::string& value);
  std::string* _internal_mutable_child();
  public:

  // string source = 4;
  void clear_source();
  const std::string& source() const;
  void set_source(const std::string& value);
  void set_source(std::string&& value);
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  std::string* mutable_source();
  std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // uint64 call_count = 3;
  void clear_call_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 call_count() const;
  void set_call_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_call_count() const;
  void _internal_set_call_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:jaeger.api_v2.DependencyLink)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr child_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
  ::PROTOBUF_NAMESPACE_ID::uint64 call_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KeyValue

// string key = 1;
inline void KeyValue::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& KeyValue::key() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.KeyValue.key)
  return _internal_key();
}
inline void KeyValue::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.KeyValue.key)
}
inline std::string* KeyValue::mutable_key() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.KeyValue.key)
  return _internal_mutable_key();
}
inline const std::string& KeyValue::_internal_key() const {
  return key_.Get();
}
inline void KeyValue::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void KeyValue::set_key(std::string&& value) {
  
  key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:jaeger.api_v2.KeyValue.key)
}
inline void KeyValue::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.KeyValue.key)
}
inline void KeyValue::set_key(const char* value,
    size_t size) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.KeyValue.key)
}
inline std::string* KeyValue::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* KeyValue::release_key() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.KeyValue.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void KeyValue::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.KeyValue.key)
}

// .jaeger.api_v2.ValueType v_type = 2;
inline void KeyValue::clear_v_type() {
  v_type_ = 0;
}
inline ::jaeger::api_v2::ValueType KeyValue::_internal_v_type() const {
  return static_cast< ::jaeger::api_v2::ValueType >(v_type_);
}
inline ::jaeger::api_v2::ValueType KeyValue::v_type() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.KeyValue.v_type)
  return _internal_v_type();
}
inline void KeyValue::_internal_set_v_type(::jaeger::api_v2::ValueType value) {
  
  v_type_ = value;
}
inline void KeyValue::set_v_type(::jaeger::api_v2::ValueType value) {
  _internal_set_v_type(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.KeyValue.v_type)
}

// string v_str = 3;
inline void KeyValue::clear_v_str() {
  v_str_.ClearToEmpty();
}
inline const std::string& KeyValue::v_str() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.KeyValue.v_str)
  return _internal_v_str();
}
inline void KeyValue::set_v_str(const std::string& value) {
  _internal_set_v_str(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.KeyValue.v_str)
}
inline std::string* KeyValue::mutable_v_str() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.KeyValue.v_str)
  return _internal_mutable_v_str();
}
inline const std::string& KeyValue::_internal_v_str() const {
  return v_str_.Get();
}
inline void KeyValue::_internal_set_v_str(const std::string& value) {
  
  v_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void KeyValue::set_v_str(std::string&& value) {
  
  v_str_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:jaeger.api_v2.KeyValue.v_str)
}
inline void KeyValue::set_v_str(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  v_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.KeyValue.v_str)
}
inline void KeyValue::set_v_str(const char* value,
    size_t size) {
  
  v_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.KeyValue.v_str)
}
inline std::string* KeyValue::_internal_mutable_v_str() {
  
  return v_str_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* KeyValue::release_v_str() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.KeyValue.v_str)
  return v_str_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void KeyValue::set_allocated_v_str(std::string* v_str) {
  if (v_str != nullptr) {
    
  } else {
    
  }
  v_str_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), v_str,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.KeyValue.v_str)
}

// bool v_bool = 4;
inline void KeyValue::clear_v_bool() {
  v_bool_ = false;
}
inline bool KeyValue::_internal_v_bool() const {
  return v_bool_;
}
inline bool KeyValue::v_bool() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.KeyValue.v_bool)
  return _internal_v_bool();
}
inline void KeyValue::_internal_set_v_bool(bool value) {
  
  v_bool_ = value;
}
inline void KeyValue::set_v_bool(bool value) {
  _internal_set_v_bool(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.KeyValue.v_bool)
}

// int64 v_int64 = 5;
inline void KeyValue::clear_v_int64() {
  v_int64_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 KeyValue::_internal_v_int64() const {
  return v_int64_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 KeyValue::v_int64() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.KeyValue.v_int64)
  return _internal_v_int64();
}
inline void KeyValue::_internal_set_v_int64(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  v_int64_ = value;
}
inline void KeyValue::set_v_int64(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_v_int64(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.KeyValue.v_int64)
}

// double v_float64 = 6;
inline void KeyValue::clear_v_float64() {
  v_float64_ = 0;
}
inline double KeyValue::_internal_v_float64() const {
  return v_float64_;
}
inline double KeyValue::v_float64() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.KeyValue.v_float64)
  return _internal_v_float64();
}
inline void KeyValue::_internal_set_v_float64(double value) {
  
  v_float64_ = value;
}
inline void KeyValue::set_v_float64(double value) {
  _internal_set_v_float64(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.KeyValue.v_float64)
}

// bytes v_binary = 7;
inline void KeyValue::clear_v_binary() {
  v_binary_.ClearToEmpty();
}
inline const std::string& KeyValue::v_binary() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.KeyValue.v_binary)
  return _internal_v_binary();
}
inline void KeyValue::set_v_binary(const std::string& value) {
  _internal_set_v_binary(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.KeyValue.v_binary)
}
inline std::string* KeyValue::mutable_v_binary() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.KeyValue.v_binary)
  return _internal_mutable_v_binary();
}
inline const std::string& KeyValue::_internal_v_binary() const {
  return v_binary_.Get();
}
inline void KeyValue::_internal_set_v_binary(const std::string& value) {
  
  v_binary_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void KeyValue::set_v_binary(std::string&& value) {
  
  v_binary_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:jaeger.api_v2.KeyValue.v_binary)
}
inline void KeyValue::set_v_binary(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  v_binary_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.KeyValue.v_binary)
}
inline void KeyValue::set_v_binary(const void* value,
    size_t size) {
  
  v_binary_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.KeyValue.v_binary)
}
inline std::string* KeyValue::_internal_mutable_v_binary() {
  
  return v_binary_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* KeyValue::release_v_binary() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.KeyValue.v_binary)
  return v_binary_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void KeyValue::set_allocated_v_binary(std::string* v_binary) {
  if (v_binary != nullptr) {
    
  } else {
    
  }
  v_binary_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), v_binary,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.KeyValue.v_binary)
}

// -------------------------------------------------------------------

// Log

// .google.protobuf.Timestamp timestamp = 1 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool Log::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Log::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Log::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Log::timestamp() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Log.timestamp)
  return _internal_timestamp();
}
inline void Log::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jaeger.api_v2.Log.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Log::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Log::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.Log.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Log::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Log::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Log.timestamp)
  return _internal_mutable_timestamp();
}
inline void Log::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.Log.timestamp)
}

// repeated .jaeger.api_v2.KeyValue fields = 2 [(.gogoproto.nullable) = false];
inline int Log::_internal_fields_size() const {
  return fields_.size();
}
inline int Log::fields_size() const {
  return _internal_fields_size();
}
inline void Log::clear_fields() {
  fields_.Clear();
}
inline ::jaeger::api_v2::KeyValue* Log::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Log.fields)
  return fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue >*
Log::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:jaeger.api_v2.Log.fields)
  return &fields_;
}
inline const ::jaeger::api_v2::KeyValue& Log::_internal_fields(int index) const {
  return fields_.Get(index);
}
inline const ::jaeger::api_v2::KeyValue& Log::fields(int index) const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Log.fields)
  return _internal_fields(index);
}
inline ::jaeger::api_v2::KeyValue* Log::_internal_add_fields() {
  return fields_.Add();
}
inline ::jaeger::api_v2::KeyValue* Log::add_fields() {
  // @@protoc_insertion_point(field_add:jaeger.api_v2.Log.fields)
  return _internal_add_fields();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue >&
Log::fields() const {
  // @@protoc_insertion_point(field_list:jaeger.api_v2.Log.fields)
  return fields_;
}

// -------------------------------------------------------------------

// SpanRef

// bytes trace_id = 1 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "TraceID", (.gogoproto.customname) = "TraceID"];
inline void SpanRef::clear_trace_id() {
  trace_id_.ClearToEmpty();
}
inline const std::string& SpanRef::trace_id() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.SpanRef.trace_id)
  return _internal_trace_id();
}
inline void SpanRef::set_trace_id(const std::string& value) {
  _internal_set_trace_id(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.SpanRef.trace_id)
}
inline std::string* SpanRef::mutable_trace_id() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.SpanRef.trace_id)
  return _internal_mutable_trace_id();
}
inline const std::string& SpanRef::_internal_trace_id() const {
  return trace_id_.Get();
}
inline void SpanRef::_internal_set_trace_id(const std::string& value) {
  
  trace_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SpanRef::set_trace_id(std::string&& value) {
  
  trace_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:jaeger.api_v2.SpanRef.trace_id)
}
inline void SpanRef::set_trace_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  trace_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.SpanRef.trace_id)
}
inline void SpanRef::set_trace_id(const void* value,
    size_t size) {
  
  trace_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.SpanRef.trace_id)
}
inline std::string* SpanRef::_internal_mutable_trace_id() {
  
  return trace_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SpanRef::release_trace_id() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.SpanRef.trace_id)
  return trace_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SpanRef::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    
  } else {
    
  }
  trace_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trace_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.SpanRef.trace_id)
}

// bytes span_id = 2 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "SpanID", (.gogoproto.customname) = "SpanID"];
inline void SpanRef::clear_span_id() {
  span_id_.ClearToEmpty();
}
inline const std::string& SpanRef::span_id() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.SpanRef.span_id)
  return _internal_span_id();
}
inline void SpanRef::set_span_id(const std::string& value) {
  _internal_set_span_id(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.SpanRef.span_id)
}
inline std::string* SpanRef::mutable_span_id() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.SpanRef.span_id)
  return _internal_mutable_span_id();
}
inline const std::string& SpanRef::_internal_span_id() const {
  return span_id_.Get();
}
inline void SpanRef::_internal_set_span_id(const std::string& value) {
  
  span_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SpanRef::set_span_id(std::string&& value) {
  
  span_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:jaeger.api_v2.SpanRef.span_id)
}
inline void SpanRef::set_span_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  span_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.SpanRef.span_id)
}
inline void SpanRef::set_span_id(const void* value,
    size_t size) {
  
  span_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.SpanRef.span_id)
}
inline std::string* SpanRef::_internal_mutable_span_id() {
  
  return span_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SpanRef::release_span_id() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.SpanRef.span_id)
  return span_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SpanRef::set_allocated_span_id(std::string* span_id) {
  if (span_id != nullptr) {
    
  } else {
    
  }
  span_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), span_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.SpanRef.span_id)
}

// .jaeger.api_v2.SpanRefType ref_type = 3;
inline void SpanRef::clear_ref_type() {
  ref_type_ = 0;
}
inline ::jaeger::api_v2::SpanRefType SpanRef::_internal_ref_type() const {
  return static_cast< ::jaeger::api_v2::SpanRefType >(ref_type_);
}
inline ::jaeger::api_v2::SpanRefType SpanRef::ref_type() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.SpanRef.ref_type)
  return _internal_ref_type();
}
inline void SpanRef::_internal_set_ref_type(::jaeger::api_v2::SpanRefType value) {
  
  ref_type_ = value;
}
inline void SpanRef::set_ref_type(::jaeger::api_v2::SpanRefType value) {
  _internal_set_ref_type(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.SpanRef.ref_type)
}

// -------------------------------------------------------------------

// Process

// string service_name = 1;
inline void Process::clear_service_name() {
  service_name_.ClearToEmpty();
}
inline const std::string& Process::service_name() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Process.service_name)
  return _internal_service_name();
}
inline void Process::set_service_name(const std::string& value) {
  _internal_set_service_name(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.Process.service_name)
}
inline std::string* Process::mutable_service_name() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Process.service_name)
  return _internal_mutable_service_name();
}
inline const std::string& Process::_internal_service_name() const {
  return service_name_.Get();
}
inline void Process::_internal_set_service_name(const std::string& value) {
  
  service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Process::set_service_name(std::string&& value) {
  
  service_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:jaeger.api_v2.Process.service_name)
}
inline void Process::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.Process.service_name)
}
inline void Process::set_service_name(const char* value,
    size_t size) {
  
  service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.Process.service_name)
}
inline std::string* Process::_internal_mutable_service_name() {
  
  return service_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Process::release_service_name() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.Process.service_name)
  return service_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Process::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.Process.service_name)
}

// repeated .jaeger.api_v2.KeyValue tags = 2 [(.gogoproto.nullable) = false];
inline int Process::_internal_tags_size() const {
  return tags_.size();
}
inline int Process::tags_size() const {
  return _internal_tags_size();
}
inline void Process::clear_tags() {
  tags_.Clear();
}
inline ::jaeger::api_v2::KeyValue* Process::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Process.tags)
  return tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue >*
Process::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:jaeger.api_v2.Process.tags)
  return &tags_;
}
inline const ::jaeger::api_v2::KeyValue& Process::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const ::jaeger::api_v2::KeyValue& Process::tags(int index) const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Process.tags)
  return _internal_tags(index);
}
inline ::jaeger::api_v2::KeyValue* Process::_internal_add_tags() {
  return tags_.Add();
}
inline ::jaeger::api_v2::KeyValue* Process::add_tags() {
  // @@protoc_insertion_point(field_add:jaeger.api_v2.Process.tags)
  return _internal_add_tags();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue >&
Process::tags() const {
  // @@protoc_insertion_point(field_list:jaeger.api_v2.Process.tags)
  return tags_;
}

// -------------------------------------------------------------------

// Span

// bytes trace_id = 1 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "TraceID", (.gogoproto.customname) = "TraceID"];
inline void Span::clear_trace_id() {
  trace_id_.ClearToEmpty();
}
inline const std::string& Span::trace_id() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Span.trace_id)
  return _internal_trace_id();
}
inline void Span::set_trace_id(const std::string& value) {
  _internal_set_trace_id(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.Span.trace_id)
}
inline std::string* Span::mutable_trace_id() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Span.trace_id)
  return _internal_mutable_trace_id();
}
inline const std::string& Span::_internal_trace_id() const {
  return trace_id_.Get();
}
inline void Span::_internal_set_trace_id(const std::string& value) {
  
  trace_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Span::set_trace_id(std::string&& value) {
  
  trace_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:jaeger.api_v2.Span.trace_id)
}
inline void Span::set_trace_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  trace_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.Span.trace_id)
}
inline void Span::set_trace_id(const void* value,
    size_t size) {
  
  trace_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.Span.trace_id)
}
inline std::string* Span::_internal_mutable_trace_id() {
  
  return trace_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Span::release_trace_id() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.Span.trace_id)
  return trace_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Span::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    
  } else {
    
  }
  trace_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trace_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.Span.trace_id)
}

// bytes span_id = 2 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "SpanID", (.gogoproto.customname) = "SpanID"];
inline void Span::clear_span_id() {
  span_id_.ClearToEmpty();
}
inline const std::string& Span::span_id() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Span.span_id)
  return _internal_span_id();
}
inline void Span::set_span_id(const std::string& value) {
  _internal_set_span_id(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.Span.span_id)
}
inline std::string* Span::mutable_span_id() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Span.span_id)
  return _internal_mutable_span_id();
}
inline const std::string& Span::_internal_span_id() const {
  return span_id_.Get();
}
inline void Span::_internal_set_span_id(const std::string& value) {
  
  span_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Span::set_span_id(std::string&& value) {
  
  span_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:jaeger.api_v2.Span.span_id)
}
inline void Span::set_span_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  span_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.Span.span_id)
}
inline void Span::set_span_id(const void* value,
    size_t size) {
  
  span_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.Span.span_id)
}
inline std::string* Span::_internal_mutable_span_id() {
  
  return span_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Span::release_span_id() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.Span.span_id)
  return span_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Span::set_allocated_span_id(std::string* span_id) {
  if (span_id != nullptr) {
    
  } else {
    
  }
  span_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), span_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.Span.span_id)
}

// string operation_name = 3;
inline void Span::clear_operation_name() {
  operation_name_.ClearToEmpty();
}
inline const std::string& Span::operation_name() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Span.operation_name)
  return _internal_operation_name();
}
inline void Span::set_operation_name(const std::string& value) {
  _internal_set_operation_name(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.Span.operation_name)
}
inline std::string* Span::mutable_operation_name() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Span.operation_name)
  return _internal_mutable_operation_name();
}
inline const std::string& Span::_internal_operation_name() const {
  return operation_name_.Get();
}
inline void Span::_internal_set_operation_name(const std::string& value) {
  
  operation_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Span::set_operation_name(std::string&& value) {
  
  operation_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:jaeger.api_v2.Span.operation_name)
}
inline void Span::set_operation_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  operation_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.Span.operation_name)
}
inline void Span::set_operation_name(const char* value,
    size_t size) {
  
  operation_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.Span.operation_name)
}
inline std::string* Span::_internal_mutable_operation_name() {
  
  return operation_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Span::release_operation_name() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.Span.operation_name)
  return operation_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Span::set_allocated_operation_name(std::string* operation_name) {
  if (operation_name != nullptr) {
    
  } else {
    
  }
  operation_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operation_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.Span.operation_name)
}

// repeated .jaeger.api_v2.SpanRef references = 4 [(.gogoproto.nullable) = false];
inline int Span::_internal_references_size() const {
  return references_.size();
}
inline int Span::references_size() const {
  return _internal_references_size();
}
inline void Span::clear_references() {
  references_.Clear();
}
inline ::jaeger::api_v2::SpanRef* Span::mutable_references(int index) {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Span.references)
  return references_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::SpanRef >*
Span::mutable_references() {
  // @@protoc_insertion_point(field_mutable_list:jaeger.api_v2.Span.references)
  return &references_;
}
inline const ::jaeger::api_v2::SpanRef& Span::_internal_references(int index) const {
  return references_.Get(index);
}
inline const ::jaeger::api_v2::SpanRef& Span::references(int index) const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Span.references)
  return _internal_references(index);
}
inline ::jaeger::api_v2::SpanRef* Span::_internal_add_references() {
  return references_.Add();
}
inline ::jaeger::api_v2::SpanRef* Span::add_references() {
  // @@protoc_insertion_point(field_add:jaeger.api_v2.Span.references)
  return _internal_add_references();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::SpanRef >&
Span::references() const {
  // @@protoc_insertion_point(field_list:jaeger.api_v2.Span.references)
  return references_;
}

// uint32 flags = 5 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "Flags"];
inline void Span::clear_flags() {
  flags_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Span::_internal_flags() const {
  return flags_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Span::flags() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Span.flags)
  return _internal_flags();
}
inline void Span::_internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  flags_ = value;
}
inline void Span::set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.Span.flags)
}

// .google.protobuf.Timestamp start_time = 6 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool Span::_internal_has_start_time() const {
  return this != internal_default_instance() && start_time_ != nullptr;
}
inline bool Span::has_start_time() const {
  return _internal_has_start_time();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Span::_internal_start_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = start_time_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Span::start_time() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Span.start_time)
  return _internal_start_time();
}
inline void Span::unsafe_arena_set_allocated_start_time(
    PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time_);
  }
  start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jaeger.api_v2.Span.start_time)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Span::release_start_time() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_time_;
  start_time_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Span::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.Span.start_time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_time_;
  start_time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Span::_internal_mutable_start_time() {
  
  if (start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    start_time_ = p;
  }
  return start_time_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Span::mutable_start_time() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Span.start_time)
  return _internal_mutable_start_time();
}
inline void Span::set_allocated_start_time(PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time)->GetArena();
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.Span.start_time)
}

// .google.protobuf.Duration duration = 7 [(.gogoproto.nullable) = false, (.gogoproto.stdduration) = true];
inline bool Span::_internal_has_duration() const {
  return this != internal_default_instance() && duration_ != nullptr;
}
inline bool Span::has_duration() const {
  return _internal_has_duration();
}
inline const PROTOBUF_NAMESPACE_ID::Duration& Span::_internal_duration() const {
  const PROTOBUF_NAMESPACE_ID::Duration* p = duration_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Duration&>(
      PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Duration& Span::duration() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Span.duration)
  return _internal_duration();
}
inline void Span::unsafe_arena_set_allocated_duration(
    PROTOBUF_NAMESPACE_ID::Duration* duration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  duration_ = duration;
  if (duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jaeger.api_v2.Span.duration)
}
inline PROTOBUF_NAMESPACE_ID::Duration* Span::release_duration() {
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = duration_;
  duration_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* Span::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.Span.duration)
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = duration_;
  duration_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* Span::_internal_mutable_duration() {
  
  if (duration_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Duration>(GetArena());
    duration_ = p;
  }
  return duration_;
}
inline PROTOBUF_NAMESPACE_ID::Duration* Span::mutable_duration() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Span.duration)
  return _internal_mutable_duration();
}
inline void Span::set_allocated_duration(PROTOBUF_NAMESPACE_ID::Duration* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration)->GetArena();
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    
  } else {
    
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.Span.duration)
}

// repeated .jaeger.api_v2.KeyValue tags = 8 [(.gogoproto.nullable) = false];
inline int Span::_internal_tags_size() const {
  return tags_.size();
}
inline int Span::tags_size() const {
  return _internal_tags_size();
}
inline void Span::clear_tags() {
  tags_.Clear();
}
inline ::jaeger::api_v2::KeyValue* Span::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Span.tags)
  return tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue >*
Span::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:jaeger.api_v2.Span.tags)
  return &tags_;
}
inline const ::jaeger::api_v2::KeyValue& Span::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const ::jaeger::api_v2::KeyValue& Span::tags(int index) const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Span.tags)
  return _internal_tags(index);
}
inline ::jaeger::api_v2::KeyValue* Span::_internal_add_tags() {
  return tags_.Add();
}
inline ::jaeger::api_v2::KeyValue* Span::add_tags() {
  // @@protoc_insertion_point(field_add:jaeger.api_v2.Span.tags)
  return _internal_add_tags();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::KeyValue >&
Span::tags() const {
  // @@protoc_insertion_point(field_list:jaeger.api_v2.Span.tags)
  return tags_;
}

// repeated .jaeger.api_v2.Log logs = 9 [(.gogoproto.nullable) = false];
inline int Span::_internal_logs_size() const {
  return logs_.size();
}
inline int Span::logs_size() const {
  return _internal_logs_size();
}
inline void Span::clear_logs() {
  logs_.Clear();
}
inline ::jaeger::api_v2::Log* Span::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Span.logs)
  return logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Log >*
Span::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:jaeger.api_v2.Span.logs)
  return &logs_;
}
inline const ::jaeger::api_v2::Log& Span::_internal_logs(int index) const {
  return logs_.Get(index);
}
inline const ::jaeger::api_v2::Log& Span::logs(int index) const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Span.logs)
  return _internal_logs(index);
}
inline ::jaeger::api_v2::Log* Span::_internal_add_logs() {
  return logs_.Add();
}
inline ::jaeger::api_v2::Log* Span::add_logs() {
  // @@protoc_insertion_point(field_add:jaeger.api_v2.Span.logs)
  return _internal_add_logs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Log >&
Span::logs() const {
  // @@protoc_insertion_point(field_list:jaeger.api_v2.Span.logs)
  return logs_;
}

// .jaeger.api_v2.Process process = 10;
inline bool Span::_internal_has_process() const {
  return this != internal_default_instance() && process_ != nullptr;
}
inline bool Span::has_process() const {
  return _internal_has_process();
}
inline void Span::clear_process() {
  if (GetArena() == nullptr && process_ != nullptr) {
    delete process_;
  }
  process_ = nullptr;
}
inline const ::jaeger::api_v2::Process& Span::_internal_process() const {
  const ::jaeger::api_v2::Process* p = process_;
  return p != nullptr ? *p : reinterpret_cast<const ::jaeger::api_v2::Process&>(
      ::jaeger::api_v2::_Process_default_instance_);
}
inline const ::jaeger::api_v2::Process& Span::process() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Span.process)
  return _internal_process();
}
inline void Span::unsafe_arena_set_allocated_process(
    ::jaeger::api_v2::Process* process) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(process_);
  }
  process_ = process;
  if (process) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jaeger.api_v2.Span.process)
}
inline ::jaeger::api_v2::Process* Span::release_process() {
  
  ::jaeger::api_v2::Process* temp = process_;
  process_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::jaeger::api_v2::Process* Span::unsafe_arena_release_process() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.Span.process)
  
  ::jaeger::api_v2::Process* temp = process_;
  process_ = nullptr;
  return temp;
}
inline ::jaeger::api_v2::Process* Span::_internal_mutable_process() {
  
  if (process_ == nullptr) {
    auto* p = CreateMaybeMessage<::jaeger::api_v2::Process>(GetArena());
    process_ = p;
  }
  return process_;
}
inline ::jaeger::api_v2::Process* Span::mutable_process() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Span.process)
  return _internal_mutable_process();
}
inline void Span::set_allocated_process(::jaeger::api_v2::Process* process) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete process_;
  }
  if (process) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(process);
    if (message_arena != submessage_arena) {
      process = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, process, submessage_arena);
    }
    
  } else {
    
  }
  process_ = process;
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.Span.process)
}

// string process_id = 11 [(.gogoproto.customname) = "ProcessID"];
inline void Span::clear_process_id() {
  process_id_.ClearToEmpty();
}
inline const std::string& Span::process_id() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Span.process_id)
  return _internal_process_id();
}
inline void Span::set_process_id(const std::string& value) {
  _internal_set_process_id(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.Span.process_id)
}
inline std::string* Span::mutable_process_id() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Span.process_id)
  return _internal_mutable_process_id();
}
inline const std::string& Span::_internal_process_id() const {
  return process_id_.Get();
}
inline void Span::_internal_set_process_id(const std::string& value) {
  
  process_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Span::set_process_id(std::string&& value) {
  
  process_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:jaeger.api_v2.Span.process_id)
}
inline void Span::set_process_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  process_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.Span.process_id)
}
inline void Span::set_process_id(const char* value,
    size_t size) {
  
  process_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.Span.process_id)
}
inline std::string* Span::_internal_mutable_process_id() {
  
  return process_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Span::release_process_id() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.Span.process_id)
  return process_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Span::set_allocated_process_id(std::string* process_id) {
  if (process_id != nullptr) {
    
  } else {
    
  }
  process_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), process_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.Span.process_id)
}

// repeated string warnings = 12;
inline int Span::_internal_warnings_size() const {
  return warnings_.size();
}
inline int Span::warnings_size() const {
  return _internal_warnings_size();
}
inline void Span::clear_warnings() {
  warnings_.Clear();
}
inline std::string* Span::add_warnings() {
  // @@protoc_insertion_point(field_add_mutable:jaeger.api_v2.Span.warnings)
  return _internal_add_warnings();
}
inline const std::string& Span::_internal_warnings(int index) const {
  return warnings_.Get(index);
}
inline const std::string& Span::warnings(int index) const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Span.warnings)
  return _internal_warnings(index);
}
inline std::string* Span::mutable_warnings(int index) {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Span.warnings)
  return warnings_.Mutable(index);
}
inline void Span::set_warnings(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:jaeger.api_v2.Span.warnings)
  warnings_.Mutable(index)->assign(value);
}
inline void Span::set_warnings(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:jaeger.api_v2.Span.warnings)
  warnings_.Mutable(index)->assign(std::move(value));
}
inline void Span::set_warnings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.Span.warnings)
}
inline void Span::set_warnings(int index, const char* value, size_t size) {
  warnings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.Span.warnings)
}
inline std::string* Span::_internal_add_warnings() {
  return warnings_.Add();
}
inline void Span::add_warnings(const std::string& value) {
  warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jaeger.api_v2.Span.warnings)
}
inline void Span::add_warnings(std::string&& value) {
  warnings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jaeger.api_v2.Span.warnings)
}
inline void Span::add_warnings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jaeger.api_v2.Span.warnings)
}
inline void Span::add_warnings(const char* value, size_t size) {
  warnings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jaeger.api_v2.Span.warnings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Span::warnings() const {
  // @@protoc_insertion_point(field_list:jaeger.api_v2.Span.warnings)
  return warnings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Span::mutable_warnings() {
  // @@protoc_insertion_point(field_mutable_list:jaeger.api_v2.Span.warnings)
  return &warnings_;
}

// -------------------------------------------------------------------

// Trace_ProcessMapping

// string process_id = 1 [(.gogoproto.customname) = "ProcessID"];
inline void Trace_ProcessMapping::clear_process_id() {
  process_id_.ClearToEmpty();
}
inline const std::string& Trace_ProcessMapping::process_id() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Trace.ProcessMapping.process_id)
  return _internal_process_id();
}
inline void Trace_ProcessMapping::set_process_id(const std::string& value) {
  _internal_set_process_id(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.Trace.ProcessMapping.process_id)
}
inline std::string* Trace_ProcessMapping::mutable_process_id() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Trace.ProcessMapping.process_id)
  return _internal_mutable_process_id();
}
inline const std::string& Trace_ProcessMapping::_internal_process_id() const {
  return process_id_.Get();
}
inline void Trace_ProcessMapping::_internal_set_process_id(const std::string& value) {
  
  process_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Trace_ProcessMapping::set_process_id(std::string&& value) {
  
  process_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:jaeger.api_v2.Trace.ProcessMapping.process_id)
}
inline void Trace_ProcessMapping::set_process_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  process_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.Trace.ProcessMapping.process_id)
}
inline void Trace_ProcessMapping::set_process_id(const char* value,
    size_t size) {
  
  process_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.Trace.ProcessMapping.process_id)
}
inline std::string* Trace_ProcessMapping::_internal_mutable_process_id() {
  
  return process_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Trace_ProcessMapping::release_process_id() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.Trace.ProcessMapping.process_id)
  return process_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Trace_ProcessMapping::set_allocated_process_id(std::string* process_id) {
  if (process_id != nullptr) {
    
  } else {
    
  }
  process_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), process_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.Trace.ProcessMapping.process_id)
}

// .jaeger.api_v2.Process process = 2 [(.gogoproto.nullable) = false];
inline bool Trace_ProcessMapping::_internal_has_process() const {
  return this != internal_default_instance() && process_ != nullptr;
}
inline bool Trace_ProcessMapping::has_process() const {
  return _internal_has_process();
}
inline void Trace_ProcessMapping::clear_process() {
  if (GetArena() == nullptr && process_ != nullptr) {
    delete process_;
  }
  process_ = nullptr;
}
inline const ::jaeger::api_v2::Process& Trace_ProcessMapping::_internal_process() const {
  const ::jaeger::api_v2::Process* p = process_;
  return p != nullptr ? *p : reinterpret_cast<const ::jaeger::api_v2::Process&>(
      ::jaeger::api_v2::_Process_default_instance_);
}
inline const ::jaeger::api_v2::Process& Trace_ProcessMapping::process() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Trace.ProcessMapping.process)
  return _internal_process();
}
inline void Trace_ProcessMapping::unsafe_arena_set_allocated_process(
    ::jaeger::api_v2::Process* process) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(process_);
  }
  process_ = process;
  if (process) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jaeger.api_v2.Trace.ProcessMapping.process)
}
inline ::jaeger::api_v2::Process* Trace_ProcessMapping::release_process() {
  
  ::jaeger::api_v2::Process* temp = process_;
  process_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::jaeger::api_v2::Process* Trace_ProcessMapping::unsafe_arena_release_process() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.Trace.ProcessMapping.process)
  
  ::jaeger::api_v2::Process* temp = process_;
  process_ = nullptr;
  return temp;
}
inline ::jaeger::api_v2::Process* Trace_ProcessMapping::_internal_mutable_process() {
  
  if (process_ == nullptr) {
    auto* p = CreateMaybeMessage<::jaeger::api_v2::Process>(GetArena());
    process_ = p;
  }
  return process_;
}
inline ::jaeger::api_v2::Process* Trace_ProcessMapping::mutable_process() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Trace.ProcessMapping.process)
  return _internal_mutable_process();
}
inline void Trace_ProcessMapping::set_allocated_process(::jaeger::api_v2::Process* process) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete process_;
  }
  if (process) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(process);
    if (message_arena != submessage_arena) {
      process = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, process, submessage_arena);
    }
    
  } else {
    
  }
  process_ = process;
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.Trace.ProcessMapping.process)
}

// -------------------------------------------------------------------

// Trace

// repeated .jaeger.api_v2.Span spans = 1;
inline int Trace::_internal_spans_size() const {
  return spans_.size();
}
inline int Trace::spans_size() const {
  return _internal_spans_size();
}
inline void Trace::clear_spans() {
  spans_.Clear();
}
inline ::jaeger::api_v2::Span* Trace::mutable_spans(int index) {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Trace.spans)
  return spans_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Span >*
Trace::mutable_spans() {
  // @@protoc_insertion_point(field_mutable_list:jaeger.api_v2.Trace.spans)
  return &spans_;
}
inline const ::jaeger::api_v2::Span& Trace::_internal_spans(int index) const {
  return spans_.Get(index);
}
inline const ::jaeger::api_v2::Span& Trace::spans(int index) const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Trace.spans)
  return _internal_spans(index);
}
inline ::jaeger::api_v2::Span* Trace::_internal_add_spans() {
  return spans_.Add();
}
inline ::jaeger::api_v2::Span* Trace::add_spans() {
  // @@protoc_insertion_point(field_add:jaeger.api_v2.Trace.spans)
  return _internal_add_spans();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Span >&
Trace::spans() const {
  // @@protoc_insertion_point(field_list:jaeger.api_v2.Trace.spans)
  return spans_;
}

// repeated .jaeger.api_v2.Trace.ProcessMapping process_map = 2 [(.gogoproto.nullable) = false];
inline int Trace::_internal_process_map_size() const {
  return process_map_.size();
}
inline int Trace::process_map_size() const {
  return _internal_process_map_size();
}
inline void Trace::clear_process_map() {
  process_map_.Clear();
}
inline ::jaeger::api_v2::Trace_ProcessMapping* Trace::mutable_process_map(int index) {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Trace.process_map)
  return process_map_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Trace_ProcessMapping >*
Trace::mutable_process_map() {
  // @@protoc_insertion_point(field_mutable_list:jaeger.api_v2.Trace.process_map)
  return &process_map_;
}
inline const ::jaeger::api_v2::Trace_ProcessMapping& Trace::_internal_process_map(int index) const {
  return process_map_.Get(index);
}
inline const ::jaeger::api_v2::Trace_ProcessMapping& Trace::process_map(int index) const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Trace.process_map)
  return _internal_process_map(index);
}
inline ::jaeger::api_v2::Trace_ProcessMapping* Trace::_internal_add_process_map() {
  return process_map_.Add();
}
inline ::jaeger::api_v2::Trace_ProcessMapping* Trace::add_process_map() {
  // @@protoc_insertion_point(field_add:jaeger.api_v2.Trace.process_map)
  return _internal_add_process_map();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Trace_ProcessMapping >&
Trace::process_map() const {
  // @@protoc_insertion_point(field_list:jaeger.api_v2.Trace.process_map)
  return process_map_;
}

// repeated string warnings = 3;
inline int Trace::_internal_warnings_size() const {
  return warnings_.size();
}
inline int Trace::warnings_size() const {
  return _internal_warnings_size();
}
inline void Trace::clear_warnings() {
  warnings_.Clear();
}
inline std::string* Trace::add_warnings() {
  // @@protoc_insertion_point(field_add_mutable:jaeger.api_v2.Trace.warnings)
  return _internal_add_warnings();
}
inline const std::string& Trace::_internal_warnings(int index) const {
  return warnings_.Get(index);
}
inline const std::string& Trace::warnings(int index) const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Trace.warnings)
  return _internal_warnings(index);
}
inline std::string* Trace::mutable_warnings(int index) {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Trace.warnings)
  return warnings_.Mutable(index);
}
inline void Trace::set_warnings(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:jaeger.api_v2.Trace.warnings)
  warnings_.Mutable(index)->assign(value);
}
inline void Trace::set_warnings(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:jaeger.api_v2.Trace.warnings)
  warnings_.Mutable(index)->assign(std::move(value));
}
inline void Trace::set_warnings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.Trace.warnings)
}
inline void Trace::set_warnings(int index, const char* value, size_t size) {
  warnings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.Trace.warnings)
}
inline std::string* Trace::_internal_add_warnings() {
  return warnings_.Add();
}
inline void Trace::add_warnings(const std::string& value) {
  warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jaeger.api_v2.Trace.warnings)
}
inline void Trace::add_warnings(std::string&& value) {
  warnings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jaeger.api_v2.Trace.warnings)
}
inline void Trace::add_warnings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jaeger.api_v2.Trace.warnings)
}
inline void Trace::add_warnings(const char* value, size_t size) {
  warnings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jaeger.api_v2.Trace.warnings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Trace::warnings() const {
  // @@protoc_insertion_point(field_list:jaeger.api_v2.Trace.warnings)
  return warnings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Trace::mutable_warnings() {
  // @@protoc_insertion_point(field_mutable_list:jaeger.api_v2.Trace.warnings)
  return &warnings_;
}

// -------------------------------------------------------------------

// Batch

// repeated .jaeger.api_v2.Span spans = 1;
inline int Batch::_internal_spans_size() const {
  return spans_.size();
}
inline int Batch::spans_size() const {
  return _internal_spans_size();
}
inline void Batch::clear_spans() {
  spans_.Clear();
}
inline ::jaeger::api_v2::Span* Batch::mutable_spans(int index) {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Batch.spans)
  return spans_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Span >*
Batch::mutable_spans() {
  // @@protoc_insertion_point(field_mutable_list:jaeger.api_v2.Batch.spans)
  return &spans_;
}
inline const ::jaeger::api_v2::Span& Batch::_internal_spans(int index) const {
  return spans_.Get(index);
}
inline const ::jaeger::api_v2::Span& Batch::spans(int index) const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Batch.spans)
  return _internal_spans(index);
}
inline ::jaeger::api_v2::Span* Batch::_internal_add_spans() {
  return spans_.Add();
}
inline ::jaeger::api_v2::Span* Batch::add_spans() {
  // @@protoc_insertion_point(field_add:jaeger.api_v2.Batch.spans)
  return _internal_add_spans();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jaeger::api_v2::Span >&
Batch::spans() const {
  // @@protoc_insertion_point(field_list:jaeger.api_v2.Batch.spans)
  return spans_;
}

// .jaeger.api_v2.Process process = 2 [(.gogoproto.nullable) = true];
inline bool Batch::_internal_has_process() const {
  return this != internal_default_instance() && process_ != nullptr;
}
inline bool Batch::has_process() const {
  return _internal_has_process();
}
inline void Batch::clear_process() {
  if (GetArena() == nullptr && process_ != nullptr) {
    delete process_;
  }
  process_ = nullptr;
}
inline const ::jaeger::api_v2::Process& Batch::_internal_process() const {
  const ::jaeger::api_v2::Process* p = process_;
  return p != nullptr ? *p : reinterpret_cast<const ::jaeger::api_v2::Process&>(
      ::jaeger::api_v2::_Process_default_instance_);
}
inline const ::jaeger::api_v2::Process& Batch::process() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.Batch.process)
  return _internal_process();
}
inline void Batch::unsafe_arena_set_allocated_process(
    ::jaeger::api_v2::Process* process) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(process_);
  }
  process_ = process;
  if (process) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jaeger.api_v2.Batch.process)
}
inline ::jaeger::api_v2::Process* Batch::release_process() {
  
  ::jaeger::api_v2::Process* temp = process_;
  process_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::jaeger::api_v2::Process* Batch::unsafe_arena_release_process() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.Batch.process)
  
  ::jaeger::api_v2::Process* temp = process_;
  process_ = nullptr;
  return temp;
}
inline ::jaeger::api_v2::Process* Batch::_internal_mutable_process() {
  
  if (process_ == nullptr) {
    auto* p = CreateMaybeMessage<::jaeger::api_v2::Process>(GetArena());
    process_ = p;
  }
  return process_;
}
inline ::jaeger::api_v2::Process* Batch::mutable_process() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.Batch.process)
  return _internal_mutable_process();
}
inline void Batch::set_allocated_process(::jaeger::api_v2::Process* process) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete process_;
  }
  if (process) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(process);
    if (message_arena != submessage_arena) {
      process = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, process, submessage_arena);
    }
    
  } else {
    
  }
  process_ = process;
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.Batch.process)
}

// -------------------------------------------------------------------

// DependencyLink

// string parent = 1;
inline void DependencyLink::clear_parent() {
  parent_.ClearToEmpty();
}
inline const std::string& DependencyLink::parent() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.DependencyLink.parent)
  return _internal_parent();
}
inline void DependencyLink::set_parent(const std::string& value) {
  _internal_set_parent(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.DependencyLink.parent)
}
inline std::string* DependencyLink::mutable_parent() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.DependencyLink.parent)
  return _internal_mutable_parent();
}
inline const std::string& DependencyLink::_internal_parent() const {
  return parent_.Get();
}
inline void DependencyLink::_internal_set_parent(const std::string& value) {
  
  parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DependencyLink::set_parent(std::string&& value) {
  
  parent_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:jaeger.api_v2.DependencyLink.parent)
}
inline void DependencyLink::set_parent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.DependencyLink.parent)
}
inline void DependencyLink::set_parent(const char* value,
    size_t size) {
  
  parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.DependencyLink.parent)
}
inline std::string* DependencyLink::_internal_mutable_parent() {
  
  return parent_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DependencyLink::release_parent() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.DependencyLink.parent)
  return parent_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DependencyLink::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  parent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.DependencyLink.parent)
}

// string child = 2;
inline void DependencyLink::clear_child() {
  child_.ClearToEmpty();
}
inline const std::string& DependencyLink::child() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.DependencyLink.child)
  return _internal_child();
}
inline void DependencyLink::set_child(const std::string& value) {
  _internal_set_child(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.DependencyLink.child)
}
inline std::string* DependencyLink::mutable_child() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.DependencyLink.child)
  return _internal_mutable_child();
}
inline const std::string& DependencyLink::_internal_child() const {
  return child_.Get();
}
inline void DependencyLink::_internal_set_child(const std::string& value) {
  
  child_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DependencyLink::set_child(std::string&& value) {
  
  child_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:jaeger.api_v2.DependencyLink.child)
}
inline void DependencyLink::set_child(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  child_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.DependencyLink.child)
}
inline void DependencyLink::set_child(const char* value,
    size_t size) {
  
  child_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.DependencyLink.child)
}
inline std::string* DependencyLink::_internal_mutable_child() {
  
  return child_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DependencyLink::release_child() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.DependencyLink.child)
  return child_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DependencyLink::set_allocated_child(std::string* child) {
  if (child != nullptr) {
    
  } else {
    
  }
  child_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), child,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.DependencyLink.child)
}

// uint64 call_count = 3;
inline void DependencyLink::clear_call_count() {
  call_count_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DependencyLink::_internal_call_count() const {
  return call_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DependencyLink::call_count() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.DependencyLink.call_count)
  return _internal_call_count();
}
inline void DependencyLink::_internal_set_call_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  call_count_ = value;
}
inline void DependencyLink::set_call_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_call_count(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.DependencyLink.call_count)
}

// string source = 4;
inline void DependencyLink::clear_source() {
  source_.ClearToEmpty();
}
inline const std::string& DependencyLink::source() const {
  // @@protoc_insertion_point(field_get:jaeger.api_v2.DependencyLink.source)
  return _internal_source();
}
inline void DependencyLink::set_source(const std::string& value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:jaeger.api_v2.DependencyLink.source)
}
inline std::string* DependencyLink::mutable_source() {
  // @@protoc_insertion_point(field_mutable:jaeger.api_v2.DependencyLink.source)
  return _internal_mutable_source();
}
inline const std::string& DependencyLink::_internal_source() const {
  return source_.Get();
}
inline void DependencyLink::_internal_set_source(const std::string& value) {
  
  source_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DependencyLink::set_source(std::string&& value) {
  
  source_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:jaeger.api_v2.DependencyLink.source)
}
inline void DependencyLink::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  source_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:jaeger.api_v2.DependencyLink.source)
}
inline void DependencyLink::set_source(const char* value,
    size_t size) {
  
  source_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:jaeger.api_v2.DependencyLink.source)
}
inline std::string* DependencyLink::_internal_mutable_source() {
  
  return source_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DependencyLink::release_source() {
  // @@protoc_insertion_point(field_release:jaeger.api_v2.DependencyLink.source)
  return source_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DependencyLink::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  source_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:jaeger.api_v2.DependencyLink.source)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api_v2
}  // namespace jaeger

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::jaeger::api_v2::ValueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jaeger::api_v2::ValueType>() {
  return ::jaeger::api_v2::ValueType_descriptor();
}
template <> struct is_proto_enum< ::jaeger::api_v2::SpanRefType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jaeger::api_v2::SpanRefType>() {
  return ::jaeger::api_v2::SpanRefType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_model_2eproto
